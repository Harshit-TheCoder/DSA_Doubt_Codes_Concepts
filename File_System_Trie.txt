Problem Overview ‚Äì What's Going On?
You‚Äôre given a list of folder paths where each path is an array of strings (representing folders).
Your task is to identify all folders that are structurally identical, even if they‚Äôre at different locations in the file system ‚Äî and delete them and their entire subtrees.

Example:

Paths = [
  ["a"], ["a", "x"], ["a", "x", "y"], ["a", "z"],
  ["b"], ["b", "x"], ["b", "x", "y"], ["b", "z"]
]
Both /a and /b have the exact same subfolder structure. Therefore, delete both completely.

üîç What Is a Duplicate Folder Structure?
A folder structure is not considered duplicate based on folder name alone. Instead, it‚Äôs considered duplicate if and only if:

"The set of child folders and their subfolders are identical in structure and names."

For example:

/a        ‚Ü≥ x       ‚Ü≥ y
          ‚Ü≥ z

/b        ‚Ü≥ x       ‚Ü≥ y
          ‚Ü≥ z
‚úÖ Same child structure ‚Üí considered duplicates ‚Üí deleted.
Now consider:

/a        ‚Ü≥ b       ‚Ü≥ c

/d        ‚Ü≥ b       ‚Ü≥ d
Even though both /a/b and /d/b exist ‚Äî they are not structurally identical ‚Üí ‚ùå not deleted.

üß† Step-by-Step Solution Explained
‚úÖ Step 1: Build the File Tree (Like a Trie)
We represent the filesystem using a custom tree node structure, where each folder is a node.

Each node stores:

Folder name

A TreeMap of children (to ensure consistent order during serialization)

A string signature to uniquely represent its subtree structure

We build the tree by:

Inserting each path one by one.

Creating nodes if they don‚Äôt exist.

This gives us a full tree of the filesystem.

üß¨ Step 2: Serialize Each Subtree to Detect Duplicates
We now perform post-order DFS (children first) to compute a signature for each subtree.

Example Signature:

For structure:
  "b" ‚Ü≥ "c"
  "d"
Signature of "b" = b(c())
Signature of root = a(b(c())d())

This uniquely identifies the structure. If two nodes generate the same signature, then they‚Äôre identical folders.

We keep a Map<String, Integer> to count how many times each signature appears.

‚ùå Step 3: Second DFS to Delete Duplicates
Now we traverse the tree again:

For each node, if its signature occurs more than once, we skip that node and its children (i.e., delete it).
Otherwise, we record the full path and continue traversal.
This ensures that all duplicates and their subfolders are removed, and only unique paths remain.


class Solution {
    class Trie {
        class Node {
            Map<String, Node> links = new HashMap<>();
            boolean isEnd = false, toDelete = false;
            String value = "";
            String serial = "";
        }

        Node root = new Node();
        Map<String, Integer> serialCount = new HashMap<>();

        void insert(List<String> path) {
            Node node = root;
            for (String folder : path) {
                node.links.putIfAbsent(folder, new Node());
                node = node.links.get(folder);
                node.value = folder;
            }
            node.isEnd = true;
        }

        String serialize(Node node) {
            if (node.links.isEmpty()) {
                node.serial = "";
                return "";
            }

            List<String> parts = new ArrayList<>();
            for (Map.Entry<String, Node> entry : node.links.entrySet()) {
                String serialized = "(" + entry.getKey() + serialize(entry.getValue()) + ")";
                parts.add(serialized);
            }

            Collections.sort(parts);
            String hash = String.join("", parts);
            serialCount.put(hash, serialCount.getOrDefault(hash, 0) + 1);
            node.serial = hash;
            return hash;
        }

        void mark(Node node) {
            if (serialCount.getOrDefault(node.serial, 0) > 1) {
                node.toDelete = true;
            }

            for (Node child : node.links.values()) {
                mark(child);
            }
        }

        void collectPaths(Node node, List<String> currPath, List<List<String>> result) {
            if (node != root && node.isEnd && !node.toDelete) {
                result.add(new ArrayList<>(currPath));
            }

            for (Map.Entry<String, Node> entry : node.links.entrySet()) {
                if (!entry.getValue().toDelete) {
                    currPath.add(entry.getKey());
                    collectPaths(entry.getValue(), currPath, result);
                    currPath.remove(currPath.size() - 1);
                }
            }
        }
    }

    public List<List<String>> deleteDuplicateFolder(List<List<String>> paths) {
        Trie trie = new Trie();
        for (List<String> path : paths) {
            trie.insert(path);
        }

        trie.serialize(trie.root);
        trie.mark(trie.root);

        List<List<String>> result = new ArrayList<>();
        trie.collectPaths(trie.root, new ArrayList<>(), result);
        return result;
    }
}
